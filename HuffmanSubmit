import java.io.*;
import java.util.*;

// Author: Linzan Ye, Jiahao Lu

public class HuffmanSubmit implements Huffman {

	// Instance variables
	static HashMap<Character, Integer> freq = null;
	static ArrayList<Character> freqArr = new ArrayList<Character>();
	static int charPos = 0;
	static HuffTree ht;
	static HuffTrees<Character> htNode;
	static HuffmanSubmit huffman;

	// Main method
	public static void main(String[] args) {
		
		HuffmanSubmit huffman = new HuffmanSubmit();
		huffman.encode("alice30.txt", "alice30enc.txt", "freqFile.txt");
		
		// System.out.println(freq.get('.'));
		// System.out.println(freq.get('A'));

		System.out.println(freq.get('a'));
		System.out.println(ht.code.get('a'));

		// huffman.decode("ur.enc", "ur_dec.jpg", "freq.txt");
		// After decoding, both ur.jpg and ur_dec.jpg should be the same.
		// On linux and mac, you can use `diff' command to check if they are the same.
	}

	public void encode(String inputFile, String outputFile, String freqFile) {
		// TODO: Your code here
		BinaryIn in = new BinaryIn(inputFile);
		scanFrequency(in);
		createFreqFile(freq, freqFile);
		ht = new HuffTree();
		ht.readHashFreq();
		ht.printHeap();
		htNode = ht.buildTree();
		ht.getBinaryCode(htNode.root, "");
		ht.traverse(htNode.root);
		createOutputFile(inputFile, outputFile, ht);
	}

	public void createOutputFile(String inputFile, String output, HuffTree ht) {
		BinaryIn in = new BinaryIn(inputFile);
		BinaryOut out = new BinaryOut(output);

		while (!in.isEmpty()) {
			char c = in.readChar();
			out.write(ht.code.get(c));
		}

	}

	public void decode(String inputFile, String outputFile, String freqFile) {
		// TODO: Your code here
	}

	public void scanFrequency(BinaryIn in) {
		freq = new HashMap<Character, Integer>();
		while (!in.isEmpty()) {
			char c = in.readChar();
			if (freq.containsKey(c)) {
				freq.put(c, freq.get(c) + 1);
			} else {
				freqArr.add(c);
				freq.put(c, 1);
			}
		}
	}

	public void createFreqFile(HashMap<Character, Integer> a, String file) {
		BinaryOut out = new BinaryOut(file);
		for (int i = 0; i < freqArr.size(); i++) {
			out.write(asciiToBinary(freqArr.get(i).toString()));
			out.write(": ");
			out.write(freq.get(freqArr.get(i)).toString());
			out.write(System.getProperty("line.separator"));
		}
		out.flush();
	}

	public static String asciiToBinary(String asciiString) {

		byte[] bytes = asciiString.getBytes();
		StringBuilder binary = new StringBuilder();
		for (byte b : bytes) {
			int val = b;
			for (int i = 0; i < 8; i++) {
				binary.append((val & 128) == 0 ? 0 : 1);
				val <<= 1;
			}
			// binary.append(' ');
		}
		return binary.toString();
	}

	class HuffTrees<E> implements Comparable<HuffTrees<E>> {

		private HuffNode<E> root;

		public HuffTrees(E el, int wt) {
			root = new HuffLeaf<E>(el, wt);
		}

		public HuffTrees(HuffNode<E> l, HuffNode<E> r, int wt) {
			root = new HuffInternalNode<E>(l, r, wt);
		}

		public int weight() {
			if (root.isLeaf()) {
				return ((HuffLeaf) root).weight;
			} else {
				return ((HuffInternalNode) root).weight;
			}
		}

		public int compareTo(HuffTrees<E> ht) {
			if (weight() < ht.weight()) {
				return -1;
			} else if (weight() > ht.weight()) {
				return 1;
			} else {
				return 0;
			}
		}
	}

	interface HuffNode<E> {
		int weight = 0;

		public E value();

		public boolean isLeaf();
	}

	class HuffLeaf<E> implements HuffNode<E> {
		private int weight;
		private E value;

		public HuffLeaf(E el, int wt) {
			value = el;
			weight = wt;
		}

		public boolean isLeaf() {
			return true;
		}

		public int weight() {
			return weight;
		}

		public E value() {
			return value;
		}

	}

	class HuffInternalNode<E> implements HuffNode<E> {
		private int weight = 0;
		private HuffNode<E> left;
		private HuffNode<E> right;

		public HuffInternalNode(HuffNode<E> l, HuffNode<E> r, int wt) {
			left = l;
			right = r;
			weight = wt;
		}

		public boolean isLeaf() {
			return false;
		}

		public E value() {
			return null;
		}

		public int weight() {
			return weight;
		}

		public HuffNode<E> left() {
			return left;
		}

		public HuffNode<E> right() {
			return right;
		}
	}

	class MinHeap<E extends Comparable<? super E>> {
		private int n; // Number of elements
		private E[] heap;

		public MinHeap(E[] arr, int count) {
			n = count;
			heap = arr;
			heapify();
		}

		public void heapify() {
			for (int i = n / 2 - 1; i >= 0; i--) {
				siftdown(i);
			}
		}

		public void insert(E el) {
			heap[n] = el;
			siftUp(n++);
		}

		public int heapSize() {
			return n;
		}

		public int parent(int pos) {
			assert pos > 0 : "No parent";
			return (pos - 1) / 2;
		}

		public int left(int pos) {
			assert pos < n / 2 : "No child";
			return pos * 2 + 1;
		}

		public int right(int pos) {
			assert pos < (n - 1) / 2 : "No child";
			return pos * 2 + 2;
		}

		public boolean isLeaf(int pos) {
			if (pos >= n / 2 && pos < n) {
				return true;
			}
			return false;
		}

		private void siftdown(int pos) {
			assert (pos >= 0) && (pos < n) : "illegal position";
			while (!isLeaf(pos)) {
				int j = left(pos);
				if ((j < n - 1) && (heap[j].compareTo(heap[j + 1])) > 0) {
					j++;
				}
				if (heap[pos].compareTo(heap[j]) <= 0) {
					return;
				}
				swap(heap, pos, j);
				pos = j;
			}
		}

		private void siftUp(int pos) {
			assert (pos >= 0) && (pos < n) : "illegal position";
			while (pos != 0 && heap[pos].compareTo(heap[parent(pos)]) < 0) {
				swap(heap, parent(pos), pos);
				pos = parent(pos);
			}
		}

		private E extractMin() {
			assert n > 0 : "Empty heap";
			swap(heap, 0, --n);
			if (n != 0) {
				siftdown(0);
			}
			return heap[n];
		}

		private void swap(E[] arr, int a, int b) {
			E temp = arr[a];
			arr[a] = arr[b];
			arr[b] = temp;
		}
	}

	class HuffTree {
		private MinHeap<HuffTrees<Character>> mHeap;
		private HuffTrees<Character>[] treeArr = new HuffTrees[freqArr.size()];
		public HashMap<Character, String> code = new HashMap<Character, String>();
		private int count = 0;

		public int count() {
			return count;
		}

		public HuffTrees<Character> buildTree() {
			HuffTrees<Character> h1, h2, h3 = null;
			while (mHeap.heapSize() > 1) {
				h1 = mHeap.extractMin(); // In the later while loops, a tree with children is returned.
				h2 = mHeap.extractMin();
				h3 = new HuffTrees<Character>(h1.root, h2.root, h1.weight() + h2.weight());
				mHeap.insert(h3);
			}
			return h3;
		}

		public void traverse(HuffNode<Character> hn) {
			if (hn.isLeaf()) {
				System.out.print(((HuffLeaf) hn).value() + " ");
			} else {
				traverse(((HuffInternalNode) hn).left);
				traverse(((HuffInternalNode) hn).right);
			}
		}

		public void printHeap() {
			System.out.print("The elements of the array are: ");
			int temp = 1;
			for (int i = 0; i < mHeap.heapSize(); i++) {
				System.out.print(mHeap.heap[i].weight());
				if (i != temp * 2) {
					System.out.print(" ");
				}
				if (i == 0) {
					System.out.println();
				} else if (i == temp * 2) {
					System.out.println();
					temp = i + 1;
				}
			}
			System.out.println();
		}

		public void readHashFreq() {
			System.out.println(freqArr.size());
			for (int i = 0; i < freqArr.size(); i++) {
				char c = freqArr.get(i); // Read char
				int fr = freq.get(c);
				treeArr[i] = new HuffTrees<Character>(c, fr);
			}
			mHeap = new MinHeap<HuffTrees<Character>>(treeArr, freqArr.size());
		}

		public void getBinaryCode(HuffNode<Character> node, String binary) {
			count++;
			if (node.isLeaf()) {
				System.out.println(((HuffLeaf<Character>) node).value() + "\t" + binary + "\t"
						+ ((HuffLeaf<Character>) node).weight);
				code.put(((HuffLeaf<Character>) node).value(), binary);
			} else {
				getBinaryCode(((HuffInternalNode<Character>) node).left, binary + "0");
				getBinaryCode(((HuffInternalNode<Character>) node).right, binary + "1");
			}

		}
	}

}
